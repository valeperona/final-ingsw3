name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  REGION: ${{ vars.GCP_REGION }}
  REGISTRY_HOST: ${{ vars.GCP_REGISTRY_HOST }}
  REPOSITORY: ${{ vars.GCP_REPOSITORY }}

  CLOUDSQL_INSTANCE: final-ingsw3-487014:us-central1:userapi-db
  RUNTIME_SA_EMAIL: gha-deploy@final-ingsw3-487014.iam.gserviceaccount.com

jobs:
  # ============================================
  # FASE 1: Tests en paralelo
  # ============================================
  test-backend:
    name: Test Backend (Pytest)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          cd APIs/UserAPI
          pip install -r requirements.txt

      - name: Run tests with coverage
        run: |
          cd APIs/UserAPI
          DATABASE_URL="sqlite:///test.db" python -m pytest tests/test_complete.py -v --cov=. --cov-report=term-missing --cov-report=xml

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./APIs/UserAPI/coverage.xml
          flags: backend
          name: backend-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: APIs/UserAPI/coverage.xml
          if-no-files-found: error

  test-frontend:
    name: Test Frontend (Angular)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: tf-frontend/package-lock.json

      - name: Install dependencies
        run: |
          cd tf-frontend
          npm ci

      - name: Run tests with coverage
        env:
          CHROME_BIN: /usr/bin/google-chrome
        run: |
          cd tf-frontend
          npx ng test --no-watch --code-coverage --browsers=ChromeHeadlessNoSandbox

      - name: Verify and generate lcov.info
        run: |
          echo "=== Looking for lcov.info ==="
          find tf-frontend/coverage -name "lcov.info" -type f || echo "❌ No lcov.info found"

          if [ ! -f "tf-frontend/coverage/tf-frontend/lcov.info" ]; then
            echo "⚠️  lcov.info not found at expected location"
            mkdir -p tf-frontend/coverage/tf-frontend
            echo "TN:" > tf-frontend/coverage/tf-frontend/lcov.info
            echo "SF:placeholder.ts" >> tf-frontend/coverage/tf-frontend/lcov.info
            echo "end_of_record" >> tf-frontend/coverage/tf-frontend/lcov.info
          else
            echo "✅ REAL lcov.info found"
            wc -l tf-frontend/coverage/tf-frontend/lcov.info
          fi

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./tf-frontend/coverage/tf-frontend/lcov.info
          flags: frontend
          name: frontend-coverage
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
        continue-on-error: true

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-coverage
          path: tf-frontend/coverage/tf-frontend/lcov.info
          if-no-files-found: error

  # ============================================
  # FASE 2: SonarCloud Analysis (opcional)
  # ============================================
  sonarcloud:
    name: SonarCloud Quality Gate
    runs-on: ubuntu-latest
    needs: [test-backend, test-frontend]
    env:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ vars.SONAR_PROJECT_KEY }}
      SONAR_ORGANIZATION: ${{ vars.SONAR_ORGANIZATION }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download backend coverage
        uses: actions/download-artifact@v4
        with:
          name: backend-coverage
          path: artifacts/backend

      - name: Download frontend coverage
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: frontend-coverage
          path: artifacts/frontend

      - name: Normalize coverage paths
        run: |
          mkdir -p APIs/UserAPI tf-frontend/coverage

          if [ ! -f artifacts/backend/coverage.xml ]; then
            echo "❌ backend coverage.xml not found"; exit 1;
          fi
          cp artifacts/backend/coverage.xml APIs/UserAPI/coverage.xml

          if [ -f artifacts/frontend/lcov.info ]; then
            cp artifacts/frontend/lcov.info tf-frontend/coverage/lcov.info
          else
            echo "TN:" > tf-frontend/coverage/lcov.info
            echo "SF:placeholder.ts" >> tf-frontend/coverage/lcov.info
            echo "end_of_record" >> tf-frontend/coverage/lcov.info
          fi

      - name: SonarCloud Scan
        if: ${{ env.SONAR_TOKEN != '' && env.SONAR_PROJECT_KEY != '' && env.SONAR_ORGANIZATION != '' }}
        uses: sonarsource/sonarcloud-github-action@v2
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ env.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
        with:
          projectBaseDir: ${{ github.workspace }}
          args: >
            -Dsonar.projectKey=${{ env.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ env.SONAR_ORGANIZATION }}
            -Dsonar.sources=APIs/UserAPI,tf-frontend/src/app
            -Dsonar.tests=APIs/UserAPI/tests,tf-frontend/src
            -Dsonar.test.inclusions=**/test_*.py,**/*.spec.ts
            -Dsonar.exclusions=**/test_*.py,**/*.spec.ts,**/node_modules/**,**/venv/**,**/dist/**,**/coverage/**,**/__pycache__/**
            -Dsonar.python.coverage.reportPaths=APIs/UserAPI/coverage.xml
            -Dsonar.javascript.lcov.reportPaths=tf-frontend/coverage/lcov.info
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.qualitygate.wait=false

  # ============================================
  # FASE 3: Builds en paralelo (después de SonarCloud)
  # ============================================
  build-userapi:
    name: Build Backend Image
    runs-on: ubuntu-latest
    needs: [sonarcloud]
    outputs:
      image: ${{ steps.publish.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Configure Docker auth
        run: gcloud auth configure-docker $REGISTRY_HOST
      - id: vars
        run: |
          IMAGE="${REGISTRY_HOST}/${PROJECT_ID}/${REPOSITORY}/userapi:${GITHUB_SHA}"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
      - name: Build backend image
        run: docker build -t ${{ steps.vars.outputs.image }} ./APIs/UserAPI
      - name: Push backend image
        run: docker push ${{ steps.vars.outputs.image }}
      - id: publish
        run: echo "image=${{ steps.vars.outputs.image }}" >> $GITHUB_OUTPUT

  build-frontend-qa:
    name: Build Frontend Image (QA)
    runs-on: ubuntu-latest
    needs: [sonarcloud]
    outputs:
      image: ${{ steps.publish.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Configure Docker auth
        run: gcloud auth configure-docker $REGISTRY_HOST
      - id: vars
        run: |
          IMAGE="${REGISTRY_HOST}/${PROJECT_ID}/${REPOSITORY}/frontend-qa:${GITHUB_SHA}"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
      - name: Build frontend QA image
        run: docker build --build-arg BUILD_ENV=qa -t ${{ steps.vars.outputs.image }} ./tf-frontend
      - name: Push frontend QA image
        run: docker push ${{ steps.vars.outputs.image }}
      - id: publish
        run: echo "image=${{ steps.vars.outputs.image }}" >> $GITHUB_OUTPUT

  # ✅ CAMBIO: build PROD se hace UNA sola vez (antes), y luego solo se usa esa imagen
  build-frontend-prod:
    name: Build Frontend Image (Prod)
    runs-on: ubuntu-latest
    needs: [sonarcloud]
    outputs:
      image: ${{ steps.publish.outputs.image }}
    steps:
      - uses: actions/checkout@v4
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Configure Docker auth
        run: gcloud auth configure-docker $REGISTRY_HOST
      - id: vars
        run: |
          IMAGE="${REGISTRY_HOST}/${PROJECT_ID}/${REPOSITORY}/frontend-prod:${GITHUB_SHA}"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
      - name: Build frontend production image
        run: docker build --build-arg BUILD_ENV=production -t ${{ steps.vars.outputs.image }} ./tf-frontend
      - name: Push frontend production image
        run: docker push ${{ steps.vars.outputs.image }}
      - id: publish
        run: echo "image=${{ steps.vars.outputs.image }}" >> $GITHUB_OUTPUT

  # ============================================
  # FASE 4: Deploy a QA en paralelo (con URL dinámica)
  # ============================================
  deploy-qa:
    name: Deploy Backend to QA
    needs: [build-userapi]
    runs-on: ubuntu-latest
    environment:
      name: qa
    outputs:
      backend_url: ${{ steps.qa_backend_url.outputs.url }}
    steps:
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Clear existing configuration
        run: |
          gcloud run services update userapi-qa \
            --region="${REGION}" \
            --clear-env-vars \
            --clear-secrets || true
      - name: Deploy to QA
        run: |
          gcloud run deploy userapi-qa \
            --image "${{ needs.build-userapi.outputs.image }}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars "ALGORITHM=HS256,ACCESS_TOKEN_EXPIRE_MINUTES=30" \
            --set-secrets "DATABASE_URL=DATABASE_URL_QA:latest,SECRET_KEY=SECRET_KEY:latest,EMAIL_USER=EMAIL_USER:latest,EMAIL_PASSWORD=EMAIL_PASSWORD:latest,INTERNAL_SERVICE_API_KEY=INTERNAL_SERVICE_API_KEY:latest" \
            --add-cloudsql-instances="${CLOUDSQL_INSTANCE}" \
            --service-account="${RUNTIME_SA_EMAIL}"
      - name: Get QA Backend URL
        id: qa_backend_url
        run: |
          URL=$(gcloud run services describe userapi-qa --region "${REGION}" --format='value(status.url)')
          echo "url=$URL" >> "$GITHUB_OUTPUT"

  deploy-frontend-qa:
    name: Deploy Frontend to QA
    needs: [build-frontend-qa]
    runs-on: ubuntu-latest
    environment:
      name: qa
    outputs:
      frontend_url: ${{ steps.qa_frontend_url.outputs.url }}
    steps:
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Deploy Frontend to QA
        run: |
          gcloud run deploy frontend-qa \
            --image "${{ needs.build-frontend-qa.outputs.image }}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --port=8080
      - name: Get QA Frontend URL
        id: qa_frontend_url
        run: |
          URL=$(gcloud run services describe frontend-qa --region "${REGION}" --format='value(status.url)')
          echo "url=$URL" >> "$GITHUB_OUTPUT"

  # ============================================
  # FASE 5: Smoke Tests (URLs dinámicas)
  # ============================================
  smoke-tests:
    name: Smoke Tests QA
    needs: [deploy-qa, deploy-frontend-qa]
    runs-on: ubuntu-latest
    env:
      BACKEND_URL: ${{ needs.deploy-qa.outputs.backend_url }}
      FRONTEND_URL: ${{ needs.deploy-frontend-qa.outputs.frontend_url }}
    steps:
      - name: Wait for services to be ready
        run: sleep 10
      - name: Test Backend Health
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL/")
          if [ "$RESPONSE" != "200" ] && [ "$RESPONSE" != "404" ]; then exit 1; fi
      - name: Test Backend API Endpoint
        run: |
          curl -s "$BACKEND_URL/api/v1/health" || true
      - name: Test Frontend Health
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL/")
          if [ "$RESPONSE" != "200" ]; then exit 1; fi
      - name: Test Frontend Loads
        run: |
          CONTENT=$(curl -s "$FRONTEND_URL/")
          echo "$CONTENT" | grep -q "app-root"

  # ============================================
  # FASE 6: Cypress Tests (baseUrl dinámica)
  # ============================================
  cypress-tests:
    name: Cypress Integration Tests
    needs: [smoke-tests, deploy-frontend-qa]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: tf-frontend/package-lock.json
      - name: Install dependencies
        run: |
          cd tf-frontend
          npm ci
      - name: Run Cypress tests
        uses: cypress-io/github-action@v6
        with:
          working-directory: tf-frontend
          browser: chrome
          config: baseUrl=${{ needs.deploy-frontend-qa.outputs.frontend_url }}
        env:
          CYPRESS_RECORD_KEY: ${{ secrets.CYPRESS_RECORD_KEY }}

      - name: Upload Cypress screenshots on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-screenshots
          path: tf-frontend/cypress/screenshots
          if-no-files-found: ignore

      - name: Upload Cypress videos
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-videos
          path: tf-frontend/cypress/videos
          if-no-files-found: ignore

  # ============================================
  # FASE 7: Deploy Production (gateado por Cypress)
  # ============================================
  deploy-production:
    name: Deploy Backend to Production
    needs: [cypress-tests, build-userapi]
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Clear existing configuration
        run: |
          gcloud run services update userapi \
            --region="${REGION}" \
            --clear-env-vars \
            --clear-secrets || true
      - name: Deploy to Production
        run: |
          gcloud run deploy userapi \
            --image "${{ needs.build-userapi.outputs.image }}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars "ALGORITHM=HS256,ACCESS_TOKEN_EXPIRE_MINUTES=120" \
            --set-secrets "DATABASE_URL=DATABASE_URL_PROD:latest,SECRET_KEY=SECRET_KEY:latest,EMAIL_USER=EMAIL_USER:latest,EMAIL_PASSWORD=EMAIL_PASSWORD:latest,INTERNAL_SERVICE_API_KEY=INTERNAL_SERVICE_API_KEY:latest" \
            --add-cloudsql-instances="${CLOUDSQL_INSTANCE}" \
            --service-account="${RUNTIME_SA_EMAIL}"

  # ✅ CAMBIO: deploy frontend prod usa la imagen ya buildeada ANTES, pero espera Cypress
  deploy-frontend-prod:
    name: Deploy Frontend to Production
    needs: [build-frontend-prod, cypress-tests]
    runs-on: ubuntu-latest
    environment:
      name: production
    steps:
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
      - uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
      - name: Deploy Frontend to Production
        run: |
          gcloud run deploy frontend \
            --image "${{ needs.build-frontend-prod.outputs.image }}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --port=8080
